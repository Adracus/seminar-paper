\chapter{Cryptography Fundamentals}

\section{Definition}

In present and past it is and always has been important for messages to be
transmitted securely and without the danger of information disclosure.  To meet
these requirements, two main technique have emerged:

One technique is called steganography. This discipline focuses on hiding the
transmission of messages. An example for this can be found in the past: To hide
a message, one used to shave off all hairs of a messenger. Then, the message
was tattooed on the skin. After a while, when the hair grew back, the messenger
was sent to the receiver. Border controls didn't notice this kind of message
transmission at the beginning, but after a while, the controls were informed to
check if a person was transmitting that kind of message. It was genious to
covertly transmit a message, but as soon as the message was discovered, the
information was disclosed. As a result, the message itself should have some
protection, so that only the desired receiver could read it. This was the point
in time when cryptography was born.

Cryptography is the art of encrypting a message so that only receivers with
specific knowledge can obtain the plaintext. The first steps in cryptography
were simple so called substitution ciphers, when some symbols in an alphabet
were switched or rotated.

Imagine the following message:

\vspace{0.5cm}
\textit{attack at dawn}
\vspace{0.5cm}

If one substituted all "a"s with a "z" and all "t"s with an "e", the message
would look like this:

\vspace{0.5cm}
\textit{zeezck ze dzwn}
\vspace{0.5cm}

The message immediately becomes unreadable for someone who doesn't know about
the underlying subsitution. This was, when cryptanalysis comes in: If one looks
at the text, one could for example analyze the frequency of some specific
letters, in this example "z" and "e". The most common letters in the English
alphabet are "e" and "a". One could now try to substitute the letter "z" with
"e". The outcome would be

\vspace{0.5cm}
\textit{aeeack ae dawn}
\vspace{0.5cm}

If one can't guess that the message is \textit{attack at dawn}, one could
continue using cryptanalysis. Since substituting "e" with commonly used letters
fails, one could analyze two letter chains. One of the most common used two
letter combinations with "a" is "at" (as one could have guessed when seeing
"ae").  After substituting "e" with "t", the original message is revealed.

\vspace{0.5cm}
\textit{attack at dawn}
\vspace{0.5cm}

Soon, this procedure also became quite insecure and cryptographers tried to
find new ways to encrypt their messages. It was a gift for them when computers
became commonly available: Procedures requiring masses of mathematical
operations could be executed in less than a second, complex encryption
algorithms appeared.

In modern cryptography there are two main kinds of encrypting and decrypting a
message. The first kind (which was actually also the first one that emerged) is
called \textit{symmetric encryption}. This kind of cryptography uses the same
key for en- and decryption of a message. The previously mentioned substitution
cipher is a \textit{symmetric encryption}, where the substitution table is the
key which is used for en- and decryption.

The other encryption kind is called \textit{asymmetric encryption}. Here, en-
and decryption are seen as different operations. That's why one has to use an
encryption and a decryption key to perform \textit{asymmetric encryption}.

\section{Cryptographic primitives}

The most basic building blocks in the field of cryptography are known as
cryptographic primitives. They include well researched, reliable and accepted
algorithms. Digital signatures, one-way has functions, as and public key
cryptography are examples for cryptographic primitives.

\subsection{Prime numbers}

Prime numbers are natural numbers which are greater than one and only evenly
divisible by one and themselves.

Those numbers play a main role in cryptography as they are commonly used
as a security factor. For example, it is quite difficult to determine the
prime factorization of a number, as none of the existing algorithms solves
the problem in polynomial time. Therefore, prime factorization is a problem
of \textit{nondeterministic polynomial time complexity} and to factorize
large numbers, more time than the age of the universe is needed.

But how can one get prime numbers in a short amount of time? There are two
main known solutions: The first solution is to permute through all positive
natural numbers, more efficient algorithms here are for example the
\textit{Sieve of Erathostenes} or the \textit{Sieve of Atkin}. The other
main approach is the statistical or heuristic approach. Well known methods
here are the \textit{Miller Rabin Test}, a test which delivers the propability
of a number to be a prime or not. This test is used in \textit{OpenSSL} to
find large primes, which makes it possible for users of \textit{OpenSSL} to
not have primes as factors of their RSA modulus.

\subsection{RSA}
	
RSA is an asymmetric encryption standard, developed by Rivest, Shamir and
Adleman. As many other asymmetric encryptions, RSA uses a one way function
with a trapdoor. So in order to understand RSA, one has to understand the
trapdoor function. The RSA trapdoor function relies on Euler's totient function
$\phi$. This function returns the amount of numbers, which are relatively prime
and smaller than a number n. Since prime numbers are only evenly divisible by
1 and themselves, the totient function returns n - 1 for prime numbers. Also,
if you multiply a number with another, the totient function also mutliplies
with the totient function of the other number. An example:

$$\phi(13) = 12$$

$$\phi(11) = 10$$

$$13 * 11 = 143$$

$$\phi(143) = \phi(13) * \phi(11) = 120$$

RSA uses this as follows: To encrypt something, one needs the so called
public key. To decrypt something, one needs the private key. Both keys
contain the so called RSA modulus \textit{n}, which is the product of 
two primes, \textit{p} and \textit{q}. The public key additionally has
the number \textit{e} and the private key has the additional number
\textit{d}. \textit{e} is a number which is coprime to the result of
the totient function of \textit{n}. \textit{d} is the multiplicative inverse
\footnote{The multiplicative inverse of a number a is the number b where $a*b = 1$} of
\textit{e} relative to $\phi(n)$.

Having calculated those needed factors, it is easy to en- and decrypt
a message representative (usually a number). To encrypt a message, one
has to apply the following procedure:

$$c = m^e mod N$$

Where \textit{c} is the ciphertext and \textit{m} the message representative.

The decryption follows the same procedure, only \textit{c} and \textit{d} are
swapped and the exponent is \textit{d}:

$$m = c^d mod N$$

Using this procedure without further additions isn't considered safe today:
One plaintext would always produce the same ciphertext. This is why cryptographers
started to use \textit{paddings}. Paddings wrap the plaintext and the padded
text is then encrypted. After decryption, the padding has to be removed in order
to obtain the original plaintext. As a result, to en- and decrypt a message, one
has to know the RSA procedure as well as the used padding.

There are several known so called \textit{padding schemes}. The most widespread
padding was defined in \textit{PKCS \#1}, the first of a family of standards
called Public Key Kryptography Standards. To encrypt, a secret Integer $m$ is 
first encoded into an octet string using the $i2osp$ (integer to octet string 
primitive). This results in an octet string message $M$. $M$ is then
concatenated with a randomly generated octet string as well as some other control
sequences as follows:

$$EM = 0x00 || 0x02 || PS || 0x00 || M$$

Where $EM$ is the encoded message and $PS$ the randomly generated octet string.
$EM$ is then converted into the ciphertext representing integer $C$ with the $os2ip$
operation (octet string to integer primitive).

The decryption then decodes $C$ back into $EM$ and 
uses the leading $0x00$ and $0x02$ to check if the padding was
applied. If so, it uses the second $0x00$ to detect the start of the encrypted
message. In total, this encryption padding enables users to encrypt secrets with
always different integer outcomes.

\section{Cryptographic Protocols}

A cryptographic protocol is a combination of cryptographic primitives,
algorithms and possibly other cryptographic protocols. The protocol describes
how the cryptographic algorithms are used in order to increase confidentiality,
integrity and availablility of the underlying goal.

Cryptographic protocols are usually defined abstract in order to leave language
specific dificulties up to the implementation. Since only the interfaces are
defined, the developers can implement against those and therefore make sure
different implementations are compatible to each other.

\subsection{Diffie Hellmann}

\section{Secret Sharing}

The practise of secret sharing takes a secret and splits it into $n$ parts,
called shares. These shares can then be distributed among all participants, the
secret should be shared with.

Most secret sharing schemes are so called $(t, n)$-threshold schemes. Within
those schemes, $t$ is the threshold out of $n$ shares required to be able to
reconstruct the secret, therefore $t \leq n$.

The easiest form of secret sharing is to divide the secret $S$ into shares of
equal length and requiring as many shares as generated to reconstruct the
secret $S$. In a $(t, n)$-threshold scheme that would mean $t = n$.

$$S = "secret"$$
$$s_1 = "se"; s_2 = "cr"; s_3 = "et";$$

Assuming an attacker knows, the secret only consists of alphabetical characters
and that it is six characters long, then there are $6^{26} = 1.7 * 10^{20}$
possibilities.  However, if the attacker is able to obtain a share and knows
where in the secret it belongs, then the possibilities to try decrease to
$4^{26} = 4.5 * 10^{15}$. That's a factor of $37876$.

To avoid this issue a schemes shares below the threshold must not disclose any
information about the secret. This is called \textit{secure} secret sharing.
An example for a secure secret sharing scheme with a $(t, n)$-threshold is the
\textit{XOR} encryption.

$$k = n; k > 0;k, n \in \mathbb{N}$$

$$S \in \mathbb{N}$$

$$j_{i} \in \mathbb{R}; i = n$$

$$\forall m: j_{m} = Random; m = {1, 2, ..., n-1}$$

$$j_{n} = S \oplus j_{1} \oplus j_{2} \oplus ... \oplus j_{n-1} $$

$$S = j_{1} \oplus j_{2} \oplus ... \oplus j_{n-1} \oplus j_{n} $$

To perform this type of scheme $n-1$ random numbers $j_{i}$ must be generated.
Then \textit{XOR} the secret $S$ and the randomly generated numbers. Each of
the generated numbers is a share and the result of the \textit{XOR} chain being
the $n$th share. To reconstruct the secret $S$ simply \textit{XOR} the shares.
This is possible since \textit{XOR} is symmetric.

Although secret sharing through \textit{XOR} encryption is simple and fast, it
becomes impractical once there are many particpants, since all shares are
required to reconstruct the secret and $k = n$ and $n$ is large.

To solve this issue secure $(t, n)$-threshold schemes with $t < n$ must be
used.

\subsection{Shamir's Secret Sharing}

The goals of Shamir's Secret Sharing are that "knowledge of any $k$ or more
$D_i$ pieces makes $D$ easily computable; knowledge of any $k - 1$ or fewer
$D_i$ pieces leaves $D$ completely undetermined (in the sense that all its
possible values are equally likely)." With $D$ being any Data, like a secret.

Shamir's Secret Sharing is more practical since it is a real $(t, n)$-threshold
scheme as $t$ can be smaller than $n$.

$$a_{n}x^n + a_{n-1}x^{n-1} + ... + a_{3}x^3 + a_{2}x^2 + a_{1}x + a_0 $$

Shamir's Secret Sharing uses a polynomial of degree $t$ to generate secrets.
In the generated polynomial in standard form the secret would be $a_0$. The
main idea is that any polynomial can be reconstructed using $degree + 1$ points
on the function. The task of reconstruction can be accomplished using lagrange
interpolation.

In the sense of secret sharing $n$ would be any number of distinct points on
the generated polynomial, except the intercept with the value axis, which is
the secret.

The smallest degree of a polynomial, that is not a single point, is a line, a
polynomial of degree 1, it therefore be reconstructed with two points. It
consequently creates an edge condition of $t \geq 1$.

\subsection{Blakley's scheme}
\section{Practical Secret Sharing}

The math behind secret sharing schemes has been proven long ago, however, for a
human to use a secret sharing scheme practically some additions have to be
made.

Those include:

\begin{itemize}
  \item cryptographic security
  \item using strings instead of numbers
\end{itemize}

\subsection{Finite Fields}

To be cryptographically secure, the operations are to be done within finite
fields. Using shamir's secret sharing scheme that means, that the prime of the
finite field has to be larger than the secret integer. $P > S$

To get such a prime number, one has to test numbers larger than $S$. For example
for the number $S = 25$, the prime number $P$ would be $29$. In that case it is
easy to get a prime number, but for larger numbers it takes a lot of time to get
the next prime number. That's why one needs to have a more efficient method of
getting large prime numbers in a small amount of time.

To always have accurate prime numbers one has to either have a way to efficiently
calculate prime numbers as they are needed or a way to efficiently get a prime
number of a pre-computed set. Each prime number \textit{covers} its on range. For
example, for a secret $S = 14$, the prime number $P = 17$ is suitable as it
\textit{covers} the range from $13$ to $17$. As a result, the range of each
prime number $P$ is from $P_{-1} to P-1$, where $P_{-1}$ is the next smaller
prime number (and for $P = 1$ it is $0$). To represent those ranges one could
invent a range-datastructure (R-Tree is not suitable for this use case), but
if one tried to store the prime numbers from $0$ to $10^{100}$ one would need
an incredibly high amount of storage. As a result, the approach to store all
prime numbers in a large range is quite inefficient in terms of storage and
overall hard to realize.

While it is hard to identify the next prime larger than $S$, there is
a phenomenon that $2^p-1$, is likely to be a prime. These primes are called
Mersenne primes, with $p$ being the $p_{th}$ Mersenne prime. The largest known
Mersenne prime is the 48$_{th}$ and has $17,425,170$ digits.

The only limitation we have is that $P > S$, so any prime larger that the
secret is valid. Using Mersenne primes we can easily use the known primes for
the finite field to use.

This, however, creates a new limitation. A secret can thoretically be larger
than $17,425,170$ digits. To avoid using the secret sharing scheme with larger
secrets. It can previously be devided into several parts making sure, the limit
is never reached for a single part. Then the secret sharing scheme is applied to
each part instead of once per secret.

Fortunately this also has another side effect. If the secret and thus the
calculated shares could be infinitely long, then they would be very inefficient
to persist and process. Splitting allows the data to be processed sequentially,
in a stream. One large secret or shares would require one long loading and
processing operation.

\subsection{Secretly Sharing Strings}

While secure secret sharing schemes work with numbers, secrets generated by
humans are generally strings. Accordingly the schemes must be extended to
support strings.

One solution to the problem is to only allow a specific set of characters. Take
ASCII for example. ASCII has 128 characters. To convert a string to an integer
in a way that is reversible start with a result of 0. Process each character of
the string from left to right one at a time. Multiply the current result with
the length of your set of characters for every character in the string and add
the position of the current character in your set of characters, also known as
a codepoint. (see figure \ref{code:stringToInteger})

\begin{figure}
\begin{lstlisting}
STRING-TO-INTEGER(input)
  result = 0
  while char = next-character(input)
    // 128 is the length of the ASCII Charset
    result = result * 128 + CODEPOINT(char)
  return result
\end{lstlisting}
\caption{Converting an ASCII string to an integer}
\label{code:stringToInteger}
\end{figure}

\textit{DIVMOD} is the inverse function to what was applied to each of the
characters. \textit{DIVMOD} can be seen as a mathematical operation returning
two results. One of the results would be the same as if the modulo operation
was applied and the other the result of integer division.

To reconstruct the string using \textit{DIVMOD} all, that has to be done is
apply \textit{DIVMOD} to the input integer and use the result of the integer
division for the next iteration and the remainder of the modulo operation is
the codepoint of the next character. The string is reconstructed from left to
right. (see figure \ref{code:integerToString})

\begin{figure}
\begin{lstlisting}
INTEGER-TO-STRING(input)
  result = ""
  while input > 0
    // 128 is the length of the ASCII Charset
    input, codepoint = input DIVMOD 128
    result = CHAR-OF-CODEPOINT(codepoint) + result
  return result
\end{lstlisting}
\caption{Converting an integer to an ASCII string}
\label{code:integerToString}
\end{figure}

One of the challenges of secretly sharing strings however, is to support a wide
range of characters. As a result ASCII is not very effective since it limits
the characters immensely, which is a result of ASCII being created to display
only the english language. An encoding, which supports a large set of
characters and is widely used is UTF-8.

Since UTF-8 has a very large set of characters (1114112 to be exact) simply
converting all characters as explained is impractical. To allow the usage of
UTF-8 anyways the easiest solution is to encode the UTF-8 strings as Base64,
then apply the string to integer conversion as explained usind the ASCII
charset. This is possible, since all characters of Base64 are a subset of
ASCII.

\chapter{Duse}
\section{The Cryptographic Protocol}

The protocol involves a server and a client. During a secrets lifecycle, there
are four events that are relevant for the protocol creating, reading, updating,
and deleting. These are also known as \textit{CRUD}.

\subsection{Creating a secret}

When creating a secret, the client first has to retrieve all profiles of the
users the secret should be shared with. These profiles contain the public key
of each user.

Now shamir's secret sharing could be used to split the secret into shares for
each user, however, this can lead to problems. Since shamir's secret sharing
requires primes equally large as the input, it can in theory handle any size of
input, but not in practise, as it might take a long time to calculate such a
large prime. Instead the original secret is split into chunks, here called
\textit{secret parts}.

Considering that all the \textit{secret parts} are not too long to compute
primes for each of them, shamir's secret sharing can now be applied.

Once shamir's secret sharing has been applied there are shares for each user
for every secret part. These shares can then be encrypted with the previously
retrieved public keys of each user and then signed with the creating users
private key. All of this data is then send to the server to verify and save.

Shamir's secret sharing requires at least two shares to reconstruct a secret,
therefore there will always be a transparent "server"-user which gets a share
that is shared with every participant.

\begin{figure}
  \includegraphics[scale=0.65]{pictures/create_secret_sequence_diagram.png}
  \centering
  \caption{Creating a secret}
  \label{fig:creating_a_secret}
\end{figure}
