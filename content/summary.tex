\chapter{Summary}

Summary ...

\chapter{Future work}

While a working in most cases secure system has been designed in theory and
practise, there are still countless features to improve the system in terms of
features, security, and user experience.

\section{Primes with Miller Rabin}

In the current implementation of Duse, Mersenne primes are used to
compute in finite fields. They are easy to compute and there are
plenty of numbers lower than the used ones. An issue which results
of the Mersenne Primes is the predictability of the prime number
which is used for encryption. Also, encryption is limited to secrets
which are smaller than the largest prime number. If one wants to
get a larger prime number than the largest mersenne prime number the
computation time rises drastically. This is because all numbers
$< \sqrt{n}$ (where $n$ is an uneven number being tested) have to be evaluated
as possible dividers of $n$. If $n$ is not a prime, $n+1$ has to be
tested until a prime number is found. The computation time can be
decreased by applying a special version of the Sieve of Erathostenes but
it is still way too high. This is where the \textit{Miller-Rabin Test}
comes in. The Miller-Rabin Test is a Monte-Carlo algorithm. If one inputs
a number $n$, the tests has two possible results: It either returns
that $n$ is not a prime number or that $n$ is propably a prime number.
Internally, the test consist of congruency characteristics of prime numbers.
The test can be repeated and the propability of a number not being a
prime being accepted as prime is $\frac{1}{4^s}$, where s is the number
of iterations of the Miller-Rabin Test.

Although it is not as secure as exact computation, the Miller-Rabin Test
is also used in the RSA internals to get high prime numbers for the
private- and public key generation. RSA is considered as a secure
encryption scheme (also with secure paddings etc.) and if such a tested
software can rely on prime numbers generated by using the miller rabin
algorithm, Duse can too.

\section{Private key sharing}
\section{Updating key pairs}
\section{Offline access}
\section{Advanced permissions}

\section{RSA OAEP}

The PKCS\#1v1.5 padding scheme is not considered secure since
\textit{Bleichenbacher's CRYPTO 98 Paper} \cite{rsabulletin}
revealed a chosen ciphertext attack \footnote{
  An attacker is able to decrypt self-chosen ciphertexts (also
  known as Decryption Oracle). \cite[p. 70]{baumann2014kryptographische}
}.
It is still used inside TLS encryption at the time of writing,
but just because TLS does it doesn't make it right. A very important
future work is to replace the default PKCS\#1v1.5 padding scheme with
the more secure OAEP padding scheme.

The Optimal Asymmetric Encryption Padding or also \textit{OAEP}
is an algorithm which is a form of a \textit{Feistel Network}\footnote{
  Feistel Networks or Feistel Ciphers are symmetric structures which are used
  during the construction of block ciphers with the most prominent example
  being the DES encryption. In general, a Feistel cipher is a cipher which
  iteratively applies an internal function, often referred as \textit{round function}.
}. OAEP prevents information leakage caused by partial decryption of 
ciphertexts and also turns deterministic encryption schemes like RSA into
propabilistic encryption schemes. When used with RSA, OAEP is called
RSA-OAEP.

\subsection{Applying the padding}

To pad a message $m$ of length $k$ bits, one first has to choose a sequence
$r$ of $k_0$ randomly generated bits. Then one calculates

$$X = m \oplus G(r)$$

and

$$Y = r \oplus H(m \oplus G(r))$$

with $G$ and $H$ being cryptographic hash functions. To then compute the
ciphertext $c$, one finally calculates the trap door function $f$ of the
concatenation of $X$ and $Y$

$$c = f(X || Y)$$

\subsection{Striping the Padding}

In order to get $X$ and $Y$ out of $c$, one first has to unapply the
trapdoorfunction $f$.

$$X || Y = f^{-1}(c)$$

$r$ can then be reconstructed by calculating

$r = Y \oplus H(x)$

With $r$ one can finally get the original message $m$ by applying XOR
to the padding part $X$ with $G(r)$:

$$m = X \oplus G(r)$$

\section{Key establishment}

If one wants to share his secret with many others, one first encrypts the
secret into many shares with the secret sharing scheme. After that, one needs
to fetch all public keys of the secret's participants in order to encrypt the
shares so no unauthorized person has access to the share. In the current
implementation of Duse, the public keys are stored as part of a user account
in the Duse system. But the Duse system itself is \textit{not} designed to
work as a public key exchange. If it is compromised, the public key access
becomes a major attack point: A fake public key could be downloaded and shares
could be encrypted with an insecure public key. As a result, an attacker
could easily read shares without permission, if he has access to the database
or the entire Duse system. Duse is not the right place to perform public
key exchange. It is designed to host and distribute secrets to users with ease.
As mentioned before, secret exchange is still safe even if the server is compormised
but the area of public key exchange is one major attack point.
The key exchange should therefore be outsourced to another
infrastructure or happen between the users directly. There are three possible
solutions for this problem.

\subsection{Diffie-Hellman key exchange}

The Diffie-Hellman key exchange is one option. Users which want to share secrets
start the Diffie-Hellman key exchange as described in the section Cryptography
Fundamentals. But there are two main attack points here:

First, how can one user even know the IP-Address of the other user? If a compromised
Duse system hosts the address of each participant for the key exchange, one could
easily change the address so that the key exchange is made with the wrong person.

Even if this problem could be solved somehow (secret channels or manual IP transmission
between future share holders), the possibility of a man-in-the-middle attack still
exists. The attacker could easily redirect participant traffic so that all participants
actually exchange keys with the attacker than with their original target.
These insecurities as well as the huge workload each user has to do to obtain
secure IP addresses are the reason for not choosing the Diffie-Hellman key exchange
as the public key exchange protocol for Duse.

\subsection{Trust Models for Public Key Infrastructures}

To get the right public key, public key infrastructures or short \textit{PKI}s use
digital certificates. Digital certificates proof the authenticity of a key. To proof
the authenticity of such a digital signature, one can check the signature with the
public key of the signer. The authenticity of the signer itself can then be checked
by checking another digital signature. This builds up a chain of signatures and 
signers relying on each other and ends on a single certificate which has to be trusted.
Currently, there are several models of PKIs which are interesting for the use
in conjunction with duse.

\subsubsection{Strict Hierarchical PKI}

This PKI model relies on a root certification authority, short \textit{Root-CA}.
All other groups have to trust this Root-CA.
De facto a single Root-CA does not exist. There is a Root-CA for many countries
in order for them to be able to control their trust chain.
The certificate of this Root-CA, the
root certificate, has no signature and is therefore called \textit{self-signed}.
Products, like for example \textit{Google Chrome} or other main browsers are
shipped with some chosen, default trusted Root-CAs in order for the trust-chain
to work with the product. A disadvantage of this certification model is the
strong dependency on the Root-CA as well as the power the Root-CA possesses.
If one wants a trusted certificate nowadays, one has to pay a lot of money to
get one. This creates a strong conjunction of the amount of money someone has with
the trustworthyness that someone gets by obtaining an expensive, valuable certificate.

\subsubsection{Cross Certification}

Cross certification nearly has the same model of certification as the Strict
Hierarchical PKI with the difference being that there can be two or more
Root-CAs. Those independently working certification authorities mutually
sign their root certificates. This creates a sign of trust between the two
CAs. Today this is used as a method to connect two or more hierarchical PKIs
in order to achieve cross country communication. The disadvantage of this
technology is the amount of cross certificates between the several Root-CAs
which rises squarely with the number of Root-CAs.

\subsubsection{Web of Trust}

In the Web of Trust, each user can trust each other and sign their public keys.
The propability of a key belonging to a user rises with the amount of certificates
that user has received. Each user can also specify the so called owner trust on
a key of another person. The owner trust can be several levels from unknown to
not tusted to ultimate trust. If now one wants to trust another user, one can
calculate the \textit{key legitimacy} out of the number of certificates on that
key as well as the individual trust levels. The concept of the web of trust allows
control about who to trust or who not to trust. Therefore, the participants of
the web should be able to identify who to trust and they should be sophisticated
in terms of creating a trusted web.

\section{Additional clients}

Duse offers a protocol which is independent of client programming languages.
Therefore, it is easy to implement clients based on different
languages. This leads to faster adoption of the duse technology stack by
other developers and this leads to contributions of the community as well
as a better reputation for duse. One could think of clients in several
popular programming languages such as Python, but the main focus of planned
clients is the availability of duse on lots of various platforms.
Planned are client implementations for the JVM as well as directly executable
machine code clients for various PC architectures. Additionally, a working
Javascript client should be established because of the cross compilation issue.

\subsection{Javascript client}

There are two approaches in implementing a Javascript client: The first
approach is by cross compiling the backend language into Javascript. There
is a well-maintained compiler for this purpose, but arbitrary size integers
have to be implemented there as well. The other approach is by writing
an entirely new client in vanilla Javascript. An advantage of a pure JS
client would be that the Javascript community has access to a clean
implementation of the duse technology stack.

\subsection{JVM-based client}

The JVM is available on lots of different architectures and offers a good 
abstraction on which many languages build. Some mentionable languages here are
of course Java, Scala and Clojure. These languages are bytecode compatible,
a single implementation here could be used across several JVM based languages.
As such, the JVM offers a broad developer community in which duse should
integrate in order for better adaption as well as a better availability of
clients. A difficulty of JVM based languages is the final packaging of the
executable software for different operating systems because of the dependency
on a specific JVM. Hence, a client in machine code should also exist.

\subsection{Machine code client}

Machine code clients have several advantages: They are easy to ship (compile
once per OS and underlying architecture) and usually performing rapidly.
Languages for this use case are for example C, Go, Rust and Nim.


\section{Mark as insecure (either key of user compromised or secret itself compromised)}
\section{Expiry date}
\section{Client side signature checks}
\section{Using symmetric encryption in conjunction with the current system}
\section{Event logging}
\section{Groups}
